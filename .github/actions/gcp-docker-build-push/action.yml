name: GCP Docker Build and Push
description: Build and push Docker image to GCP Artifact Container Registry
inputs:
  gcp-credentials:
    required: true
    description: "GCP Service Account JSON key"
  gcp-project-id:
    required: true
    description: "GCP Project ID"
  gcp-region:
    required: true
    description: "GCP Region"
  gcp-artifact-repo:
    required: true
    description: "GCP Artifact Container Registry name"
  github-token:
    required: true
    description: "GitHub Access Token"
  image-name:
    required: true
    description: "Docker image name"
  image-tag:
    required: false
    description: "Docker image tag"
  dockerfile:
    required: false
    description: "Dockerfile path"
    default: ${{ github.workspace }}/Dockerfile
  build-context:
    required: false
    description: "Docker build context"
    default: ${{ github.workspace }}
  build-args:
    required: false
    description: "Docker build argument"
  cache-key:
    required: false
    description: "Docker build extra cache key - useful for tags involving drastic changes in the image build"
    default: ""
runs:
  using: "composite"
  steps:
    - uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ inputs.gcp-credentials }}

    - uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ inputs.gcp-project-id }}

    - name: Docker auth
      shell: bash
      run: gcloud auth configure-docker ${{ inputs.gcp-region }}-docker.pkg.dev --quiet

    - name: Set image tag
      shell: bash
      id: vars
      env:
        GCP_REGION: ${{ inputs.gcp-region }}
        GCP_PROJECT_ID: ${{ inputs.gcp-project-id }}
        GCP_ARTIFACT_REPO: ${{ inputs.gcp-artifact-repo }}
        IMAGE_NAME: ${{ inputs.image-name }}
        IMAGE_TAG: ${{ inputs.image-tag }}
      run: |
        IMAGE="$GCP_REGION-docker.pkg.dev/$GCP_PROJECT_ID/$GCP_ARTIFACT_REPO/$IMAGE_NAME"
        if [ ! -z "$IMAGE_TAG" ]; then
          # Handle multi-line tags (newline separated)
          TAGS=""
          while IFS= read -r tag || [ -n "$tag" ]; do
            tag=$(echo "$tag" | xargs)  # trim whitespace
            if [ -n "$tag" ]; then
              if [ -z "$TAGS" ]; then
                TAGS="$IMAGE:$tag"
              else
                TAGS="$TAGS,$IMAGE:$tag"
              fi
            fi
          done <<< "$IMAGE_TAG"
        elif [[ "${GITHUB_REF_TYPE}" == "tag" && "${GITHUB_REF_NAME}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          TAGS="$IMAGE:${GITHUB_REF_NAME}"
        elif [[ "${GITHUB_REF_NAME}" == "main" ]]; then
          TAGS="$IMAGE:latest"
        elif [[ "${GITHUB_REF_NAME}" == "development" ]]; then
          TAGS="$IMAGE:dev"
        else
          echo "No matching condition for build, skipping."
          exit 0
        fi
        CACHE_KEY=""
        if [ ! -z "${{ inputs.cache-key }}" ]; then
          CACHE_KEY="-${{ inputs.cache-key }}"
        fi
        echo "tags=$TAGS" >> $GITHUB_OUTPUT
        echo "cache-image=$IMAGE:buildcache${CACHE_KEY}" >> $GITHUB_OUTPUT

    - name: Set up QEMU and Buildx
      uses: docker/setup-buildx-action@v3

    - name: Create ephemeral .netrc for private module access
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
        GITHUB_ACTOR: ${{ github.actor }}
      run: |
        echo -e "machine github.com\nlogin ${GITHUB_ACTOR}\npassword ${GITHUB_TOKEN}" > $HOME/.netrc
        chmod 600 $HOME/.netrc

    - name: Build and push with .netrc secret
      uses: docker/build-push-action@v6
      with:
        push: true
        file: ${{ inputs.dockerfile }}
        context: ${{ inputs.build-context }}
        tags: ${{ steps.vars.outputs.tags }}
        build-args: ${{ inputs.build-args }}
        secret-files: |
          netrc=/home/runner/.netrc
        cache-from: type=registry,ref=${{ steps.vars.outputs.cache-image }}
        cache-to: type=registry,ref=${{ steps.vars.outputs.cache-image }},mode=max
